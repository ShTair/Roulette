@inject IJSRuntime JS
@using System
@using System.IO
@using System.Linq
@using Roulette.Models
@using nietras.SeparatedValues

<div class="mb-3">
    <h5 class="tool-header" @onclick="ToggleOpen">
        <span class="triangle @(open ? "open" : string.Empty)">▼</span> CSVツール
    </h5>
    @if (open)
    {
        <div class="alert alert-warning">
            <p class="mb-1">
                <strong>設定一覧ページの「設定書き出し」とは、書き出されるファイルが異なる</strong>ことに注意してください。<br />
                このツールは、現在開いているルーレットの項目をCSVで編集するためのものです。
                「設定書き出し」で書きだしたファイルをここで取り込んだり、ここで書き出したファイルを設定一覧ページで読み込んだりはできません。<br />
            </p>
            <p class="mb-1">
                <strong>CSV取り込みルール:</strong>
            </p>
            <ul class="mb-0">
                <li>
                    <strong>項目名の列は必須</strong>ですが、他の列は無くてもいいです。
                    <ul class="mb-0">
                        <li>既に登録されている項目と同じ項目名を読み込むと、その設定値が上書きされます。そもそも同じ項目名の項目が複数ある場合、おかしくなるので注意してください。</li>
                        <li>同じ項目名の項目が無い場合、項目が新規作成されます。</li>
                    </ul>
                </li>
                <li>項目上書きの時、セルが空白だったり、そもそも列が無い設定は、登録済みの項目の値が維持されます。</li>
            </ul>
        </div>
        <div class="mb-3 d-flex">
            <button class="btn btn-secondary" @onclick="ExportCsv">CSV書き出し</button>
            <button class="btn btn-secondary ms-2" @onclick="TriggerCsvImport">CSV読み込み</button>
            <InputFile OnChange="ImportCsv" style="display:none" @ref="csvInput" accept=".csv,text/csv" />
        </div>
    }
</div>

@code {
    [Parameter] public List<RouletteItem> Items { get; set; } = new();
    [Parameter] public RouletteConfig? CurrentConfig { get; set; }
    [Parameter] public EventCallback OnChanged { get; set; }

    private bool open;

    private void ToggleOpen() => open = !open;

    private InputFile? csvInput;

    private string GenerateCsv()
    {
        using var writer = Sep.Writer(o => o with { Sep = new Sep(',') }).ToText();
        foreach (var item in Items)
        {
            using var row = writer.NewRow();
            row["項目名"].Set(item.Text);
            row["背景色"].Set(item.Color);
            row["当たり数"].Format(item.Count);
            row["サイズ"].Format(item.Size);
            row["表示状態"].Set(item.State.ToString());
        }
        return writer.ToString();
    }

    private async Task ExportCsv()
    {
        var csv = "\uFEFF" + GenerateCsv();
        var timestamp = DateTime.Now.ToString("yyyyMMddHHmmss");
        var baseName = CurrentConfig?.Name;
        if (string.IsNullOrWhiteSpace(baseName)) baseName = "items";
        var fileName = $"{baseName}_{timestamp}.csv";
        await JS.InvokeVoidAsync("downloadFile", fileName, csv);
    }

    private async Task TriggerCsvImport()
    {
        if (csvInput is not null)
        {
            await JS.InvokeVoidAsync("triggerInputFile", csvInput.Element);
        }
    }

    private void ApplyCsv(string text)
    {
        using var reader = Sep.Reader(o => o with { Sep = new Sep(',') }).FromText(text);

        var header = reader.Header;
        int GetIdx(params string[] names)
        {
            foreach (var name in names)
            {
                if (header.TryIndexOf(name, out var idx)) return idx;
            }
            return -1;
        }

        var textIdx = GetIdx("項目名", "Text");
        if (textIdx < 0) return;
        var colorIdx = GetIdx("背景色", "Color");
        var countIdx = GetIdx("当たり数", "Count");
        var sizeIdx = GetIdx("サイズ", "Size");
        var stateIdx = GetIdx("表示状態", "State");

        foreach (var row in reader)
        {
            var name = row[textIdx].ToString().Trim();
            if (string.IsNullOrWhiteSpace(name)) continue;
            var item = Items.FirstOrDefault(x => x.Text == name);
            if (item is null)
            {
                var last = Items.Count > 0 ? Items[^1] : null;
                item = RouletteItem.Create(name, last?.Color);
                if (last is not null)
                {
                    item.State = last.State;
                }
                Items.Add(item);
            }
            if (colorIdx >= 0)
            {
                var color = row[colorIdx].ToString().Trim();
                if (!string.IsNullOrWhiteSpace(color)) item.Color = color;
            }
            if (countIdx >= 0)
            {
                var span = row[countIdx].Span;
                if (int.TryParse(span, out var cnt)) item.Count = cnt;
            }
            if (sizeIdx >= 0)
            {
                var span = row[sizeIdx].Span;
                if (double.TryParse(span, out var sz)) item.Size = sz;
            }
            if (stateIdx >= 0)
            {
                var stStr = row[stateIdx].ToString().Trim();
                if (Enum.TryParse<RouletteItemState>(stStr, out var st)) item.State = st;
            }
        }
    }

    private async Task ImportCsv(InputFileChangeEventArgs e)
    {
        if (e.FileCount == 0) return;
        var file = e.File;
        using var stream = file.OpenReadStream(file.Size);
        using var readerText = new StreamReader(stream);
        var text = await readerText.ReadToEndAsync();
        ApplyCsv(text);
        await OnChanged.InvokeAsync();
    }
}
